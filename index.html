<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>HighRoller: Fate or Fold</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&family=Josefin+Sans:wght@300;400;600&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0f;
  --gold: #c9a84c;
  --gold-light: #f0d080;
  --gold-dim: #7a6230;
  --card-bg: #1a1a2e;
  --text: #e8dfc8;
  --text-dim: #8a7d60;
  --glow-gold: 0 0 30px rgba(201,168,76,0.5);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Josefin Sans', sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow-x: hidden;
  position: relative;
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    radial-gradient(ellipse 80% 60% at 50% 50%, #0d2318 0%, #0a0a0f 70%),
    repeating-linear-gradient(45deg, rgba(255,255,255,0.012) 0px, rgba(255,255,255,0.012) 1px, transparent 1px, transparent 10px);
  z-index: 0;
}

body::after {
  content: '';
  position: fixed;
  inset: 0;
  background:
    radial-gradient(circle at 0% 0%, rgba(201,168,76,0.08) 0%, transparent 50%),
    radial-gradient(circle at 100% 100%, rgba(201,168,76,0.06) 0%, transparent 50%);
  z-index: 0;
  pointer-events: none;
}

.chip {
  position: fixed;
  border-radius: 50%;
  border: 3px solid;
  opacity: 0.07;
  animation: floatChip linear infinite;
  z-index: 0;
  pointer-events: none;
}
@keyframes floatChip {
  0%   { transform: translateY(110vh) rotate(0deg); }
  100% { transform: translateY(-110vh) rotate(720deg); }
}

.game-wrap {
  position: relative;
  z-index: 1;
  width: 95%;
  max-width: 480px;
  padding: 1rem;
  margin: 0 auto;
}

/* === HEADER === */
.header { text-align: center; margin-bottom: 1.5rem; }

.logo {
  font-family: 'Playfair Display', serif;
  font-size: 2.6rem;
  font-weight: 900;
  letter-spacing: 0.02em;
  background: linear-gradient(135deg, #c9a84c 0%, #f0d080 40%, #c9a84c 70%, #7a6230 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  filter: drop-shadow(0 0 20px rgba(201,168,76,0.4));
}

.tagline {
  font-size: 0.7rem;
  letter-spacing: 0.35em;
  text-transform: uppercase;
  color: var(--gold-dim);
  margin-top: 0.1rem;
}

/* === ARENA === */
.arena {
  background: linear-gradient(145deg, #111827 0%, #0d1520 100%);
  border: 1px solid rgba(201,168,76,0.2);
  border-radius: 20px;
  padding: 1.5rem;
  box-shadow:
    0 0 0 1px rgba(201,168,76,0.05),
    0 25px 60px rgba(0,0,0,0.7),
    inset 0 1px 0 rgba(201,168,76,0.1);
  position: relative;
}

/* === SCORE BAR === */
.score-bar { display: flex; justify-content: space-between; margin-bottom: 1.5rem; }
.score-item { text-align: center; flex: 1; }
.score-label { font-size: 0.6rem; letter-spacing: 0.25em; text-transform: uppercase; color: var(--text-dim); margin-bottom: 0.2rem; }
.score-value { font-family: 'Playfair Display', serif; font-size: 1.8rem; font-weight: 700; color: var(--gold); line-height: 1; }
.score-divider { width: 1px; background: linear-gradient(to bottom, transparent, var(--gold-dim), transparent); margin: 0 0.5rem; }

/* === BADGE === */
.badge-row {
  text-align: center;
  height: 1.6rem;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
}
.badge-inner {
  display: inline-block;
  background: var(--gold);
  color: #000;
  font-weight: 700;
  font-size: 0.7rem;
  letter-spacing: 0.12em;
  padding: 0.25rem 0.9rem;
  border-radius: 20px;
  transform: scale(0);
  transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}
.badge-inner.show { transform: scale(1); }

/* === 5-CARD ROW === */
.card-row-container {
  overflow: hidden;
  position: relative;
  padding: 6px 0 10px;
}

.card-row {
  display: flex;
  gap: 7px;
  justify-content: center;
}

.card-slot {
  flex: 1;
  min-width: 0;
  max-width: 80px;
  position: relative;
  will-change: transform, opacity;
}

.card-face-wrap {
  width: 100%;
  aspect-ratio: 5 / 7;
  border-radius: 9px;
  border: 1.5px solid rgba(201,168,76,0.25);
  box-shadow: 0 4px 18px rgba(0,0,0,0.55);
  background: var(--card-bg);
  position: relative;
  overflow: hidden;
  will-change: transform;
}

.card-face-wrap img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  display: block;
}

.card-back-design {
  width: 100%;
  height: 100%;
  background:
    repeating-linear-gradient( 45deg, rgba(201,168,76,0.07) 0px, rgba(201,168,76,0.07) 1px, transparent 1px, transparent 7px),
    repeating-linear-gradient(-45deg, rgba(201,168,76,0.07) 0px, rgba(201,168,76,0.07) 1px, transparent 1px, transparent 7px),
    linear-gradient(145deg, #131c2e, #0d1520);
  display: flex;
  align-items: center;
  justify-content: center;
}
.card-back-design::after {
  content: '✦';
  font-size: 1.3rem;
  color: rgba(201,168,76,0.22);
}

/* Active card border */
.card-slot.current .card-face-wrap {
  border-color: rgba(201,168,76,0.75);
  box-shadow: 0 0 14px rgba(201,168,76,0.38), 0 4px 18px rgba(0,0,0,0.55);
}

/* Next target pulse */
.card-slot.target .card-face-wrap {
  border-color: rgba(201,168,76,0.45);
  animation: targetPulse 1.8s ease-in-out infinite;
}
@keyframes targetPulse {
  0%, 100% { box-shadow: 0 0 4px rgba(201,168,76,0.1),  0 4px 18px rgba(0,0,0,0.55); }
  50%       { box-shadow: 0 0 16px rgba(201,168,76,0.4), 0 4px 18px rgba(0,0,0,0.55); }
}

/* Flip — horizontal squish */
@keyframes cardFlip {
  0%   { transform: scaleX(1); }
  42%  { transform: scaleX(0.02); }
  58%  { transform: scaleX(0.02); }
  100% { transform: scaleX(1); }
}
.card-face-wrap.do-flip { animation: cardFlip 0.48s ease forwards; }

/* Flash overlays */
.flash-overlay {
  position: absolute;
  inset: 0;
  opacity: 0;
  pointer-events: none;
}
.card-slot.flash-win  .flash-overlay { animation: flashWin  0.65s ease forwards; background: radial-gradient(circle, rgba(74,222,128,0.45) 0%, transparent 70%); }
.card-slot.flash-loss .flash-overlay { animation: flashLoss 0.65s ease forwards; background: radial-gradient(circle, rgba(248,113,113,0.5) 0%, transparent 70%); }
@keyframes flashWin  { 0% { opacity:0; } 35% { opacity:1; } 100% { opacity:0; } }
@keyframes flashLoss { 0% { opacity:0; } 35% { opacity:1; } 100% { opacity:0; } }

/* Row progress pips */
.row-progress { display: flex; justify-content: center; gap: 5px; margin-top: 0.6rem; }
.progress-pip {
  height: 3px;
  flex: 1;
  max-width: 44px;
  border-radius: 2px;
  background: rgba(201,168,76,0.12);
  transition: background 0.3s;
}
.progress-pip.done   { background: rgba(201,168,76,0.45); }
.progress-pip.active { background: var(--gold); box-shadow: 0 0 6px rgba(201,168,76,0.5); }

/* === STATUS === */
.status {
  text-align: center;
  font-size: 0.78rem;
  letter-spacing: 0.05em;
  color: var(--text-dim);
  margin: 1rem 0 1.2rem;
  min-height: 2.2em;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* === BUTTONS === */
.buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 0.8rem; }
.btn {
  padding: 0.8rem 0.4rem;
  font-family: 'Josefin Sans', sans-serif;
  font-size: 0.8rem;
  font-weight: 600;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  border: 1px solid rgba(201,168,76,0.3);
  border-radius: 12px;
  cursor: pointer;
  background: linear-gradient(145deg, rgba(201,168,76,0.08), rgba(201,168,76,0.04));
  color: var(--gold);
  transition: all 0.2s;
}
.btn:hover:not(:disabled) { border-color: var(--gold); box-shadow: var(--glow-gold); }
.btn:active { transform: scale(0.96); }
.btn:disabled { opacity: 0.28; cursor: not-allowed; }
.btn-icon { display: block; font-size: 1.2rem; margin-bottom: 0.2rem; }

/* === STREAK === */
.streak-row { display: flex; justify-content: center; gap: 0.4rem; margin-top: 1rem; }
.streak-dot { width: 8px; height: 8px; border-radius: 50%; border: 1px solid var(--gold-dim); }
.streak-dot.filled { background: var(--gold); box-shadow: 0 0 8px var(--gold); }

/* === FOOTER === */
.footer { text-align: center; margin-top: 1.5rem; }
.theme-btn { background: none; border: none; color: var(--text-dim); font-size: 0.7rem; cursor: pointer; text-transform: uppercase; font-family: 'Josefin Sans', sans-serif; }

/* === SHAKE === */
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  20% { transform: translateX(-5px); }
  40% { transform: translateX(5px); }
  60% { transform: translateX(-5px); }
  80% { transform: translateX(5px); }
}
.arena.shake { animation: shake 0.4s ease; }

/* === PARTICLES === */
#particles { position: fixed; inset: 0; pointer-events: none; z-index: 50; }
.particle { position: absolute; border-radius: 50%; animation: pFly 0.8s ease-out forwards; }
@keyframes pFly { 0% { opacity:1; transform: translate(0,0) scale(1); } 100% { opacity:0; transform: translate(var(--tx),var(--ty)) scale(0); } }

@media (max-width: 360px) {
  .logo { font-size: 2.1rem; }
  .arena { padding: 1rem; }
  .score-value { font-size: 1.5rem; }
  .card-row { gap: 5px; }
}

/* === LIGHT MODE === */
.light-mode {
  --bg: #f5f0e8;
  --gold: #7a5c1e;
  --gold-dim: #b09060;
  --text: #1a1008;
  --text-dim: #6b5a3e;
  --card-bg: #fff;
}
.light-mode body::before { background: radial-gradient(ellipse 80% 60% at 50% 50%, #ede8d8 0%, #f5f0e8 70%); }
.light-mode .arena { background: linear-gradient(145deg, #fdfbf5 0%, #f5f0e2 100%); }
.light-mode .card-back-design {
  background:
    repeating-linear-gradient( 45deg, rgba(122,92,30,0.07) 0px, rgba(122,92,30,0.07) 1px, transparent 1px, transparent 7px),
    repeating-linear-gradient(-45deg, rgba(122,92,30,0.07) 0px, rgba(122,92,30,0.07) 1px, transparent 1px, transparent 7px),
    linear-gradient(145deg, #e8e0cc, #f0e8d8);
}
</style>
</head>
<body>
<div id="particles"></div>

<div class="game-wrap">
  <div class="header">
    <div class="logo">HighRoller</div>
    <div class="tagline">Fate &bull; or &bull; Fold</div>
  </div>

  <div class="arena" id="arena">
    <div class="score-bar">
      <div class="score-item">
        <div class="score-label">Streak</div>
        <div class="score-value" id="score">0</div>
      </div>
      <div class="score-divider"></div>
      <div class="score-item">
        <div class="score-label">Best</div>
        <div class="score-value" id="highscore">0</div>
      </div>
    </div>

    <div class="badge-row">
      <span class="badge-inner" id="badgeInner">WIN</span>
    </div>

    <div class="card-row-container">
      <div class="card-row" id="cardRow"></div>
    </div>
    <div class="row-progress" id="rowProgress"></div>

    <div class="status" id="status">Place your bet &mdash; higher or lower?</div>

    <div class="buttons">
      <button class="btn" id="btnHigher" onclick="guess('higher')">
        <span class="btn-icon">▲</span>Higher
      </button>
      <button class="btn" id="btnLower" onclick="guess('lower')">
        <span class="btn-icon">▼</span>Lower
      </button>
    </div>

    <div class="streak-row" id="streakRow"></div>
  </div>

  <div class="footer">
    <button class="theme-btn" onclick="toggleTheme()" id="themeBtn">☽ Toggle Light Mode</button>
  </div>
</div>

<script>
const DECK_BASE  = "https://deckofcardsapi.com/api/deck/";
const STREAK_MAX = 10;
const ROW_SIZE   = 5;

let deckId       = null;
let cards        = [];   // [{value, numValue, image, revealed}]
let currentIndex = 0;    // face-up "compare from" card
let score        = 0;
let busy         = false;
let highscore    = parseInt(localStorage.getItem("highscore") || "0");

const scoreEl = document.getElementById("score");
const highEl  = document.getElementById("highscore");
const statusEl = document.getElementById("status");
const badgeEl  = document.getElementById("badgeInner");
const arena    = document.getElementById("arena");
const cardRow  = document.getElementById("cardRow");
const rowProg  = document.getElementById("rowProgress");
const streakRow = document.getElementById("streakRow");

highEl.textContent = highscore;

const valueMap = { ACE:14, KING:13, QUEEN:12, JACK:11 };
const cardVal  = v => valueMap[v] || parseInt(v);
const sleep    = ms => new Promise(r => setTimeout(r, ms));

// ── API ──────────────────────────────────────────────────────────────────────

async function initDeck() {
  try {
    const res  = await fetch(DECK_BASE + "new/shuffle/?deck_count=2");
    const data = await res.json();
    deckId = data.deck_id;
  } catch { deckId = null; }
}

async function drawCards(count) {
  try {
    const url  = deckId
      ? `${DECK_BASE}${deckId}/draw/?count=${count}`
      : `${DECK_BASE}new/draw/?count=${count}`;
    const res  = await fetch(url);
    const data = await res.json();
    if (data.remaining !== undefined && data.remaining < 15 && deckId) {
      fetch(`${DECK_BASE}${deckId}/shuffle/`); // async reshuffle in background
    }
    return data.cards.map(c => ({
      value: c.value, numValue: cardVal(c.value), image: c.image, revealed: false
    }));
  } catch {
    return Array.from({ length: count }, () => {
      const n = [2,3,4,5,6,7,8,9,10,11,12,13,14][Math.floor(Math.random() * 13)];
      return { value: String(n), numValue: n, image: '', revealed: false };
    });
  }
}

// ── RENDER ───────────────────────────────────────────────────────────────────

function buildSlot(card, index) {
  const slot = document.createElement('div');
  slot.className = 'card-slot';
  slot.id = 'slot-' + index;
  if (index === currentIndex)     slot.classList.add('current');
  if (index === currentIndex + 1) slot.classList.add('target');

  const wrap = document.createElement('div');
  wrap.className = 'card-face-wrap';

  if (card.revealed) {
    if (card.image) {
      const img = document.createElement('img');
      img.src = card.image;
      img.alt = card.value;
      wrap.appendChild(img);
    } else {
      Object.assign(wrap.style, { display:'flex', alignItems:'center', justifyContent:'center', color:'var(--gold)', fontSize:'1.1rem', fontWeight:'700' });
      wrap.textContent = card.value;
    }
  } else {
    const back = document.createElement('div');
    back.className = 'card-back-design';
    wrap.appendChild(back);
  }

  const overlay = document.createElement('div');
  overlay.className = 'flash-overlay';
  wrap.appendChild(overlay);

  slot.appendChild(wrap);
  return slot;
}

function renderCards() {
  cardRow.innerHTML = '';
  cards.forEach((card, i) => cardRow.appendChild(buildSlot(card, i)));
  renderProgress();
}

function renderProgress() {
  rowProg.innerHTML = '';
  for (let i = 0; i < ROW_SIZE - 1; i++) {
    const pip = document.createElement('div');
    pip.className = 'progress-pip';
    if (i < currentIndex)  pip.classList.add('done');
    if (i === currentIndex) pip.classList.add('active');
    rowProg.appendChild(pip);
  }
}

function buildStreak() {
  streakRow.innerHTML = '';
  for (let i = 0; i < STREAK_MAX; i++) {
    const d = document.createElement('div');
    d.className = 'streak-dot' + (i < score ? ' filled' : '');
    streakRow.appendChild(d);
  }
}

// ── GAME ─────────────────────────────────────────────────────────────────────

async function startGame() {
  await initDeck();
  const drawn = await drawCards(ROW_SIZE);
  cards = drawn;
  cards[0].revealed = true;
  currentIndex = 0;
  renderCards();
  buildStreak();
}

async function guess(type) {
  if (busy || currentIndex >= ROW_SIZE - 1) return;
  busy = true;
  document.getElementById("btnHigher").disabled = true;
  document.getElementById("btnLower").disabled  = true;

  const nextIdx  = currentIndex + 1;
  const nextCard = cards[nextIdx];
  const currCard = cards[currentIndex];

  // ── Flip animation ──────────────────────────────────────────────────────
  const targetSlot = document.getElementById('slot-' + nextIdx);
  const targetWrap = targetSlot?.querySelector('.card-face-wrap');

  if (targetWrap) {
    targetSlot.classList.remove('target');
    targetWrap.classList.add('do-flip');

    await sleep(230); // halfway: card is edge-on — swap content now

    targetWrap.innerHTML = '';
    nextCard.revealed = true;
    if (nextCard.image) {
      const img = document.createElement('img');
      img.src = nextCard.image;
      img.alt = nextCard.value;
      targetWrap.appendChild(img);
    } else {
      Object.assign(targetWrap.style, { display:'flex', alignItems:'center', justifyContent:'center', color:'var(--gold)', fontSize:'1.1rem', fontWeight:'700' });
      targetWrap.textContent = nextCard.value;
    }
    const ov = document.createElement('div');
    ov.className = 'flash-overlay';
    targetWrap.appendChild(ov);

    await sleep(260); // finish flip
    targetWrap.classList.remove('do-flip');
  } else {
    nextCard.revealed = true;
  }

  // ── Evaluate ────────────────────────────────────────────────────────────
  const correct = (type === 'higher' && nextCard.numValue > currCard.numValue) ||
                  (type === 'lower'  && nextCard.numValue < currCard.numValue);
  const tie     = nextCard.numValue === currCard.numValue;

  if (tie) {
    showBadge('TIE', 'tie');
    statusEl.textContent = "Dead heat — it's a push!";
    // Advance without scoring (treat like a win for flow)
    if (nextIdx === ROW_SIZE - 1) {
      await sleep(800);
      await transitionToNextRow(nextCard);
      statusEl.textContent = 'New hand dealt. Keep rolling!';
    } else {
      currentIndex = nextIdx;
      renderCards();
    }

  } else if (correct) {
    score++;
    scoreEl.textContent = score;
    showBadge('WIN ✦', 'win');
    if (targetSlot) targetSlot.classList.add('flash-win');
    burst(true);

    if (nextIdx === ROW_SIZE - 1) {
      // Cleared the whole row!
      statusEl.textContent = 'Full row cleared! Rolling new hand…';
      await sleep(950);
      await transitionToNextRow(nextCard);
      statusEl.textContent = 'New hand dealt. Keep rolling!';
    } else {
      currentIndex = nextIdx;
      renderCards();
      statusEl.textContent = 'Nice call, High Roller.';
    }

  } else {
    // Loss
    if (score > highscore) {
      highscore = score;
      localStorage.setItem('highscore', highscore);
      highEl.textContent = highscore;
    }
    showBadge('FOLD ✕', 'lose');
    statusEl.textContent = score > 0 ? `A ${score}-card streak. Respect.` : "The deck doesn't forgive.";
    if (targetSlot) targetSlot.classList.add('flash-loss');
    arena.classList.add('shake');
    burst(false);
    score = 0;
    scoreEl.textContent = 0;

    await sleep(1100);
    arena.classList.remove('shake');
    const drawn = await drawCards(ROW_SIZE);
    cards = drawn;
    cards[0].revealed = true;
    currentIndex = 0;
    renderCards();
    statusEl.textContent = 'Place your bet — higher or lower?';
  }

  buildStreak();
  document.getElementById("btnHigher").disabled = false;
  document.getElementById("btnLower").disabled  = false;
  busy = false;
}

// ── SLIDE TRANSITION (end of row → new row) ──────────────────────────────────

async function transitionToNextRow(lastCard) {
  const slots = Array.from(cardRow.querySelectorAll('.card-slot'));
  if (slots.length < ROW_SIZE) return;

  const firstRect = slots[0].getBoundingClientRect();
  const lastRect  = slots[ROW_SIZE - 1].getBoundingClientRect();
  const slideLeft = lastRect.left - firstRect.left;       // distance to travel
  const exitDist  = lastRect.right - firstRect.left + 30; // enough to clear left edge

  // Slots 0–3: slide off left and fade
  for (let i = 0; i < ROW_SIZE - 1; i++) {
    slots[i].style.transition = 'transform 0.48s ease-in, opacity 0.38s ease-in';
    slots[i].style.transform  = `translateX(-${exitDist}px)`;
    slots[i].style.opacity    = '0';
  }

  // Last slot: glide from its position to where slot 0 was
  slots[ROW_SIZE - 1].style.transition = 'transform 0.52s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
  slots[ROW_SIZE - 1].style.transform  = `translateX(-${slideLeft}px)`;

  await sleep(600);

  // Rebuild: last card at index 0, 4 fresh face-down cards
  const newCards = await drawCards(ROW_SIZE - 1);
  cards = [{ ...lastCard, revealed: true }, ...newCards];
  currentIndex = 0;
  renderCards();
}

// ── UI HELPERS ────────────────────────────────────────────────────────────────

function showBadge(text, type) {
  badgeEl.textContent = text;
  badgeEl.style.background = type === 'win' ? '#4ade80' : type === 'lose' ? '#f87171' : '#facc15';
  badgeEl.classList.add('show');
  setTimeout(() => badgeEl.classList.remove('show'), 1050);
}

function burst(win) {
  const p = document.getElementById("particles");
  const colors = win ? ['#c9a84c','#4ade80','#ffffff'] : ['#ef4444','#7f1d1d'];
  for (let i = 0; i < 16; i++) {
    const el = document.createElement('div');
    el.className = 'particle';
    const angle = Math.random() * Math.PI * 2;
    const dist  = 50 + Math.random() * 110;
    el.style.cssText = `width:6px;height:6px;background:${colors[i%colors.length]};left:50%;top:40%;--tx:${Math.cos(angle)*dist}px;--ty:${Math.sin(angle)*dist}px;`;
    p.appendChild(el);
    setTimeout(() => el.remove(), 820);
  }
}

function buildChips() {
  const colors = ['#c9a84c','#4ade80','#f87171','#60a5fa'];
  for (let i = 0; i < 6; i++) {
    const chip = document.createElement('div');
    chip.className = 'chip';
    const size = 20 + Math.random() * 40;
    chip.style.cssText = `width:${size}px;height:${size}px;left:${Math.random()*100}%;border-color:${colors[i%4]};animation-duration:${8+Math.random()*12}s;animation-delay:${-Math.random()*15}s;`;
    document.body.appendChild(chip);
  }
}

function toggleTheme() {
  document.documentElement.classList.toggle('light-mode');
  const isLight = document.documentElement.classList.contains('light-mode');
  localStorage.setItem('theme', isLight ? 'light' : 'dark');
  document.getElementById('themeBtn').textContent = isLight ? '☽ Toggle Dark Mode' : '☽ Toggle Light Mode';
}

if (localStorage.getItem('theme') === 'light') toggleTheme();
buildChips();
startGame();
</script>
</body>
</html>
